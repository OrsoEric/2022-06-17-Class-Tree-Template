/**********************************************************************************
**  ENVIROMENT VARIABILE
**********************************************************************************/

#ifndef TREE_H_
    #define TREE_H_

/**********************************************************************************
**  GLOBAL INCLUDES
**********************************************************************************/

//Used to store leaves
#include <vector>

#include "Tree_interface.h"

/**********************************************************************************
**  DEFINES
**********************************************************************************/

/**********************************************************************************
**  MACROS
**********************************************************************************/

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

//! @namespace custom namespace
namespace User
{

/**********************************************************************************
**  TYPEDEFS
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: STRUCTURES
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: GLOBAL VARIABILES
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: CLASS
**********************************************************************************/

/************************************************************************************/
//! @class      Tree
/************************************************************************************/
//!	@author     Orso Eric
//! @version    2022-06-17
//! @brief      Generic tree template implementation
//! @copyright  BSD 3-Clause License Copyright (c) 2022, Orso Eric
//! @bug Avoid push_back | add a move constructor C(C&& c) C(const &c) | use emplace-back | construct/destruct https://stackoverflow.com/questions/21798396/destructor-is-called-when-i-push-back-to-the-vector
//! @bug swap can be done with std::swap std::vector::swap, the second is the fastest for vectors | https://stackoverflow.com/questions/41090557/c-swap-two-elements-of-two-different-vectors
//! @details
//! \n	A basic tree class that stores a template payload
//! \n	Implements the generic Tree_interface
/************************************************************************************/

template <class Payload>
class Tree : public Tree_interface<Payload>
{
    //Visible to all
    public:
		/*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC ENUMS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief Configurations of the class
        union Config
        {
            //Checks to be performed on user dependent data
			static const bool CU1_EXTERNAL_CHECKS = true;
			//Checks to be performed on input dependent on internal algorithms
			static const bool CU1_INTERNAL_CHECKS = true;


			//true = pedantic count children. check all nodes, and make sure all nodes have coherent priority
			//false = fast count children. will return the max priority of the first children with the correct father, if any
			static const bool CU1_PEDANTIC_COUNT_CHILDREN = true;
        };

        //! @brief Error codes of the class
        union Error_code
        {
			//No error
			static constexpr const char *CPS8_OK = "OK";
			//Generic error
			static constexpr const char *CPS8_ERR = "ERR";
        };

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC TYPEDEFS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief Node of the tree
        struct Node
        {
			//Payload inside the node
			Payload t_payload;
			//Index of the father. using father means that there is no variable number of children index to maintain. all nodes have exactly one father except the root. It also makes it impossible to make loops. Root is the only node that has itself as father.
			typename std::vector<Node>::iterator pst_father;
			//Priority, defines the order of this node compared to its siblings, 0 is the highest priority node under the given father.
			unsigned int u32_own_priority;
			//Max Priority, it's the number of siblings. A lone child has priority of 0 and a max_priority of 1. max_priority of 0 is error.
			//Adding a children would require modifying the max priority of all children.
			//Instead the max priority of a node is equivalent to the number of children. I already have father reference to access it.
			//So it's single edit when adding/removing children. Would be multi edit on all children otherwise
			unsigned int u32_children_max_priority;
        };

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  CONSTRUCTORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Empty Constructor
        Tree( void );
        //Default payload Constructor
        Tree( Payload it_default_payload );
        //Default payload and root Constructor
        Tree( Payload it_default_payload, Payload it_root_payload );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  DESTRUCTORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Empty destructor
        ~Tree( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC OPERATORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        Payload& operator []( unsigned int iu32_index );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC SETTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Create a child of the root
		//std::vector<Node>::iterator create_child( Payload it_payload );
		bool create_child( Payload it_payload );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC GETTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Reference to Payload of the root node, overload available to discard success
        Payload &root( bool &oru1_fail );
        Payload &root( void )
        {
			bool u1_fail;
			return this->root( u1_fail );
        }
        //Show the nodes stored inside the vector and their links
		bool show( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC TESTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC STATIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

    //Visible to derived classes
    protected:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PROTECTED TYPES
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PROTECTED VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

    //Visible only inside the class
    private:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE TYPES
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE INIT
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief initialize class vars to the default
        bool init_class_vars( Payload it_payload );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Convert an iterator to a node to an index, its position in the vector
		bool convert_node_iterator_to_index( typename std::vector<Node>::iterator ipst_father, unsigned int &iru32_index );
        //Count the children of a node
        bool count_children( typename std::vector<Node>::iterator st_father, unsigned int &oru32_num_children );
		//Report an error. return false: OK | true: Unknown error code
        bool report_error( const char *ips8_error_code );
        //Tries to recover from an error. Automatically called by get_error. return false = OK | true = fail
        bool error_recovery( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//The nodes are stored inside a standard vector
        std::vector<Node> gast_nodes;
        //Stores the node that is target for tree operations
        typename std::vector<Node>::iterator pst_working_node;
};	//End Class: Tree

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	CONSTRUCTORS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Constructor: Tree | void
/***************************************************************************/
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::Tree( void )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //Initialize class vars
    this->init_class_vars( this->gt_dummy );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //Constructor: Tree | void

/***************************************************************************/
//! @brief Constructor: Tree | Payload |
/***************************************************************************/
//! @param it_default_payload | default payload
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::Tree( Payload it_default_payload )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    this->set_default_payload( it_default_payload );
    //Initialize class vars
    this->init_class_vars( it_default_payload );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //Constructor: Tree | Payload |

/***************************************************************************/
//! @brief Constructor: Tree | Payload | Payload |
/***************************************************************************/
//! @param it_default_payload | default payload
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::Tree( Payload it_default_payload, Payload it_root_payload )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    this->set_default_payload( it_default_payload );
    //Initialize class vars
    this->init_class_vars( it_root_payload );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //Constructor: Tree | Payload | Payload |

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	DESTRUCTORS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//!	@brief Destructor: Tree | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Empty destructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::~Tree( void )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	INIT
    //--------------------------------------------------------------------------



    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return;         //OK
}   //Destructor: Tree | void

/***************************************************************************/
//!	@brief operator [] | int
/***************************************************************************/
//!	@param iu32_index | Numeric index of the node
//! @return Payload & | Reference to content of the node
//!	@details
//! LHS and RHS access to the payload of a node. Returns the reference to the
//!	dummy payload if an invalid index is given, raising an error inside the tree
/***************************************************************************/

template <class Payload>
Payload& Tree<Payload>::operator []( unsigned int iu32_index )
{
	//Trace Enter
	DENTER_ARG("Object: %p, Index: %d", (void *)this, iu32_index );
	//--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

	//The user is trying to access a node outside the range
    if (iu32_index >= this->gast_nodes.size())
    {
		DRETURN_ARG("Index OOB: %d of %d", iu32_index, this->gast_nodes.size() );
		//Return a reference to the dummy payload
		return this->gt_dummy;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
	//Trace Return from main
	DRETURN();
	return this->gast_nodes[iu32_index].t_payload;
}	//end method: operator & | int |

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC SETTERS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Public Setter: create_leaf | Payload
/***************************************************************************/
//! @param it_payload | payload to be attached to this leaf
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Create a child of the root
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::create_child( Payload it_payload )
{
    DENTER(); //Trace Enter
    //--------------------------------------------------------------------------
    //	CHECK&INIT
    //--------------------------------------------------------------------------
	//if class is in error, leaf cannot be created
    if (this->gps8_error_code != Error_code::CPS8_OK)
    {
		DRETURN_ARG("ERR:%d Tree is in error: %s | Cannot create leaf", __LINE__, this->gps8_error_code );
		return true;
    }
    //Create the node to add metadata to the payload
	Node st_node;
	st_node.t_payload = it_payload;
	//This node starts with no children
	st_node.u32_children_max_priority = 0;
	st_node.u32_own_priority = 0;
	//Iterator to the root. This tree just uses father iterators for navigation and links
	st_node.pst_father = this->gast_nodes.begin();
	unsigned int u32_father_index;
	this->convert_node_iterator_to_index( st_node.pst_father, u32_father_index );
	DPRINT("Father: %d\n", u32_father_index );
	//Number of children of the father
	//Now counting children is cheap. father.u32_children_max_priority is the number of children already
	unsigned int u32_num_children = st_node.pst_father->u32_children_max_priority;
	//Count the current children of the father
    /*
    bool u1_fail = this->count_children( st_node.pst_father, u32_num_children );
    if (u1_fail == true)
    {
		this->report_error( Error_code::CPS8_ERR );
		DRETURN_ARG("ERR:%d | Could not count children for Node with index %d with %d total nodes", __LINE__, this->convert_node_iterator_to_index( st_node.pst_father ), this->gast_nodes.size() );
		return true;
    }
    */

    //BUG: I would need to update the max priority of all children...
    //IDEA: what if max priority is not duplicated and stored inside the father?
    //By the end, I will have added a children to the father
	u32_num_children++;
	//I update the number of childre, thus the max priority of the father
	st_node.pst_father->u32_children_max_priority = u32_num_children;
    //The newly created node has the lowest priority
    st_node.u32_own_priority = u32_num_children -1;

    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------
	//I search the first free spot on the vector and allocate the child

	//Add the node to the tree
	this->gast_nodes.push_back( st_node );
	/*
	//TODO: add optional check to integrity of the operation
	if (Config::CU1_PEDANTIC_COUNT_CHILDREN == true)
	{
		unsigned int u32_check_num_children;
		//Count the current children of the father
		bool u1_fail = this->count_children( st_node.pst_father, u32_check_num_children );
		if (u1_fail == true)
		{
			this->report_error( Error_code::CPS8_ERR );
			DRETURN_ARG("ERR:%d | Could not count children for Node with index %d with %d total nodes", __LINE__, this->convert_node_iterator_to_index( st_node.pst_father ), this->gast_nodes.size() );
			return true;
		}
		if (u32_check_num_children != u32_num_children)
		{
			this->report_error( Error_code::CPS8_ERR );
			DRETURN_ARG("ERR:%d | Children were not actually added for Node with index %d with %d total nodes", __LINE__, this->convert_node_iterator_to_index( st_node.pst_father ), this->gast_nodes.size() );
			return true;
		}
    }
    */

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN_ARG("Leaves: %d", u32_num_children +1 ); //Trace Return
    return false;	//OK
}   //Public Setter: create_leaf | Payload

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC GETTER
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Public getter: root | bool & |
/***************************************************************************/
//! @param oru1_fail | false = OK | true = FAIL
//! @return Payload & | Reference to the payload of the root node |
//! @details
//! \n Return the reference to the payload of the root node
/***************************************************************************/

template <class Payload>
Payload &Tree<Payload>::root( bool &oru1_fail )
{
    DENTER(); //Trace Enter
    //--------------------------------------------------------------------------
    //	INIT
    //--------------------------------------------------------------------------

    if (this->gast_nodes.size() <= 0)
    {
		this->report_error(Error_code::CPS8_ERR);
		return this->gt_dummy;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return this->gast_nodes[0].t_payload;
}   //Public getter: root | bool & |

/***************************************************************************/
//! @brief Public getter: show | void |
/***************************************************************************/
//! @param bool | false = OK | true = FAIL |
//! @details
//! \n Show the nodes stored inside the vector and their links
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::show( void )
{
    DENTER_ARG("Nodes: %d", this->gast_nodes.size()); //Trace Enter
    //--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

    if (this->gast_nodes.size() <= 0)
    {
		DRETURN_ARG("ERR:%d | Vector should contain at least the root...", __LINE__ );
		return true;
    }

    //--------------------------------------------------------------------------
    //	SHOW
    //--------------------------------------------------------------------------

	//Scan vector of nodes
    for (typename std::vector<Node>::iterator pst_node = this->gast_nodes.begin();pst_node < this->gast_nodes.end();pst_node++)
    {

		//std::ostream my_stream;
		unsigned int u32_node_index;
		this->convert_node_iterator_to_index( pst_node, u32_node_index );
		std::cout << "Index: " << u32_node_index;
		unsigned int u32_father_index;
		this->convert_node_iterator_to_index( pst_node->pst_father, u32_father_index );
		std::cout << " | Payload: " << pst_node->t_payload;
		//Root is the only node that has itself as father
		if (pst_node == pst_node->pst_father)
		{
			std::cout << " | ROOT ";
		}
		//
		std::cout << "\n";
    }


    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return this->gast_nodes[0].t_payload;
}   //Public getter: show | void |


/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/


/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE INIT
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private Method: init_class_vars | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Initialize class vars
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::init_class_vars( Payload it_payload )
{
    DENTER();		//Trace Enter
    //--------------------------------------------------------------------------
    //	INIT
    //--------------------------------------------------------------------------

	Node st_node;
    st_node.t_payload = it_payload;
    //Root starts with no children
	st_node.u32_children_max_priority = 0;
	//Root cannot have a priority
	st_node.u32_own_priority = 0;
    //Allocate root and fill root with dummy payload
    this->gast_nodes.push_back( st_node );
    if (this->gast_nodes.size() != 1)
    {
		//! @todo: Undo initialization
		this->report_error( Error_code::CPS8_ERR );
        DRETURN_ARG("ERR%d: There should be exactly one node (Root) after initialization, there are %d instead", __LINE__, this->gast_nodes.size() );
        return true;
    }
	//Register the father index. Root points to itself
    this->gast_nodes[0].pst_father = this->gast_nodes.begin();

    unsigned int u32_father_index;
	this->convert_node_iterator_to_index( this->gast_nodes[0].pst_father, u32_father_index );
    unsigned int u32_own_index;
    this->convert_node_iterator_to_index( this->gast_nodes.begin(), u32_own_index );
	DPRINT("Index: %d | Father: %d\n", u32_own_index, u32_father_index  );
    this->gps8_error_code = Error_code::CPS8_OK;

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return false;   //OK
}   //Private Method: init_class_vars | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private Method | convert_node_iterator_to_index | std::vector<Node>::iterator
/***************************************************************************/
//! @param std::vector<Node>::iterator | iterator to the node
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Convert an iterator to a node to an index, its position in the vector
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::convert_node_iterator_to_index( typename std::vector<Node>::iterator ipst_father, unsigned int &iru32_index )
{
    DENTER_ARG("This: %p, Father: %p", this, ipst_father );
    //--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

    if ( (Config::CU1_INTERNAL_CHECKS == true) && ((ipst_father < this->gast_nodes.begin()) || (ipst_father >= this->gast_nodes.end())) )
    {
		iru32_index = 0;
		DRETURN_ARG("ERR:%d | Iterator points to an address outside vector range | Begin: %p | Index %d | Size: %d", __LINE__, this->gast_nodes.begin(), ipst_father -this->gast_nodes.begin(), this->gast_nodes.end() -this->gast_nodes.begin() );
		return true;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------

	unsigned int u32_index = ipst_father -this->gast_nodes.begin();
    DRETURN_ARG("Index: %d", u32_index );
    return false;
} 	//Private Method | convert_node_iterator_to_index | std::vector<Node>::iterator

/***************************************************************************/
//! @brief Private Method | convert_node_iterator_to_index | std::vector<Node>::iterator | unsigned int & |
/***************************************************************************/
//! @param std::vector<Node>::iterator | iterator to the node
//! @param oru32_num_children | number of children of the node
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Count the number of nodes that have the iterator as father
/***************************************************************************/

/*
template <class Payload>
bool Tree<Payload>::count_children( typename std::vector<Node>::iterator ist_father, unsigned int &oru32_num_children )
{
    DENTER();
    //--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

    if ( (Config::CU1_INTERNAL_CHECKS == true) && ((ist_father < this->gast_nodes.begin()) || (ist_father >= this->gast_nodes.end())) )
    {
		//DRETURN_ARG("ERR:%d | Iterator points to an address outside vector range | Node: %p | Begin: %p | End: %p", __LINE__, st_father, this->gast_nodes.begin(), this->gast_nodes.end());
		DRETURN_ARG("ERR:%d | Iterator points to an address outside vector range | Begin: %d | End: %d", __LINE__, ist_father -this->gast_nodes.begin(), this->gast_nodes.end() -ist_father);
		return 0;
    }

    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //Initialize scan
    unsigned int u32_num_children = 0;
    typename std::vector<Node>::iterator st_iter = this->gast_nodes.begin();
	//Fast count children
	if (Config::CU1_PEDANTIC_COUNT_CHILDREN == false)
	{
		bool u1_done = false;
		//while not done
		while ((st_iter <= this->gast_nodes.end()) && (u1_done == false))
		{
			//If I find a node whose father is the given node
			if (st_iter->pst_father == ist_father)
			{
				u32_num_children = st_iter->u32_;
				u1_done = true;
			}
			//Next
			st_iter++;
		}
	}
	//Pedantic count children
    else
    {
		//Remember the maximum priority
		unsigned int u32_max_priority = 0;
		//while not done
		while (st_iter < this->gast_nodes.end())
		{
			//max priority exceed the vector size. Impossible
			if ( (Config::CU1_INTERNAL_CHECKS == true) && (st_iter->u32_max_priority > this->gast_nodes.size()) )
			{
				//Error
				this->report_error(Error_code::CPS8_ERR);
				DRETURN_ARG("ERR:%d | Max priority is %d. There are only %d nodes.", __LINE__, st_iter->u32_max_priority, this->gast_nodes.size() );
				oru32_num_children = 0;
				return true;
			}

			//If I find a node whose father is the given node
			if (st_iter->pst_father == ist_father)
			{
				//this is the first node I found
				if (u32_max_priority == 0)
				{
					//Remember max priority.
					u32_max_priority = st_iter->u32_max_priority;
					//father has a children, max priority should at least be 1
					if (u32_max_priority == 0)
					{
						//Error
						this->report_error(Error_code::CPS8_ERR);
						DRETURN_ARG("ERR:%d | Max priority is zero. There is at least one children...", __LINE__ );
						oru32_num_children = 0;
						return true;
					}
				}
				//the max priority is inconsistent
				else if (st_iter->u32_max_priority != u32_max_priority)
				{
					//Error
					this->report_error(Error_code::CPS8_ERR);
                    DRETURN_ARG("ERR:%d | Inconsistent max priority amongst children %d vs %d", __LINE__, u32_max_priority, st_iter->u32_max_priority );
                    oru32_num_children = 0;
                    return true;
				}
				//priority exceeds max priority
				else if (st_iter->u32_priority >= u32_max_priority)
				{
					//Error
					this->report_error(Error_code::CPS8_ERR);
                    DRETURN_ARG("ERR:%d | Priority %d exceed max priority %d", __LINE__, st_iter->u32_priority, u32_max_priority );
                    oru32_num_children = 0;
                    return true;
				}
				else
				{
					//Child found
					u32_num_children++;
				}
			} //If I find a node whose father is the given node
			//Node has not the given node as father
			else
			{
				//Do nothing
			}
			//Next
			st_iter++;
		}	//while not done
    }	//Pedantic count children

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN_ARG("Children: %d", u32_num_children );
    oru32_num_children = u32_num_children;
    return false;
} 	//Private Method | convert_node_iterator_to_index | std::vector<Node>::iterator
*/

/***************************************************************************/
//! @brief Private Method | report_error | Error_code
/***************************************************************************/
//! @param ips8_error_code | error string to be reported. Error strings can be stored in Error_code
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Report an error. return false: OK | true: Unknown error code
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::report_error( const char *ips8_error_code )
{
    DENTER_ARG("ERR: %p", ips8_error_code ); //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //If class is OK
    if (ips8_error_code != Error_code::CPS8_OK)
    {
		//Report current error
		this->gps8_error_code = ips8_error_code;
    }
    else
    {
		//Class was already in error. Could not
		DRETURN_ARG("ERR: Class is already in error: %p | culd not report error: %p", &this->gps8_error_code, ips8_error_code );
		return true;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return false;	//OK
} 	//Private Method: report_error | Error_code

/***************************************************************************/
//! @brief Private Method: error_recovery | void |
/***************************************************************************/
//! @return return false = OK | true = fail
//! @details
//! \n Tries to recover from an error
//! \n Automatically called by get_error.
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::error_recovery( void )
{
    DENTER_ARG("ERR: %s", this->gps8_error_code); //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------
	//If class is not OK
    if (this->gps8_error_code != Error_code::CPS8_OK)
    {
		//Class is OK
		this->gps8_error_code = Error_code::CPS8_OK;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN_ARG("Recovered: %s", this->gps8_error_code);      //Trace Return
    return false;    //FAIL
}   //Private Method: error_recovery | void |

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

}	//end namespace: User

#else
    #warning "Multiple inclusion of hader file TREE_H_"
#endif
