/**********************************************************************************
**  ENVIROMENT VARIABILE
**********************************************************************************/

#ifndef TREE_H_
    #define TREE_H_

/**********************************************************************************
**  GLOBAL INCLUDES
**********************************************************************************/

//Used to store leaves
#include <vector>

#include "Tree_interface.h"

/**********************************************************************************
**  DEFINES
**********************************************************************************/

/**********************************************************************************
**  MACROS
**********************************************************************************/

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

//! @namespace custom namespace
namespace User
{

/**********************************************************************************
**  TYPEDEFS
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: STRUCTURES
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: GLOBAL VARIABILES
**********************************************************************************/

/**********************************************************************************
**  PROTOTYPE: CLASS
**********************************************************************************/

/************************************************************************************/
//! @class      Tree
/************************************************************************************/
//!	@author     Orso Eric
//! @version    2022-06-17
//! @brief      Generic tree template implementation
//! @copyright  BSD 3-Clause License Copyright (c) 2022, Orso Eric
//! @bug Avoid push_back | add a move constructor C(C&& c) C(const &c) | use emplace-back | construct/destruct https://stackoverflow.com/questions/21798396/destructor-is-called-when-i-push-back-to-the-vector
//! @bug swap can be done with std::swap std::vector::swap, the second is the fastest for vectors | https://stackoverflow.com/questions/41090557/c-swap-two-elements-of-two-different-vectors
//! @details
//! \n	A basic tree class that stores a template payload
//! \n	Implements the generic Tree_interface
/************************************************************************************/

template <class Payload>
class Tree : public Tree_interface<Payload>
{
    //Visible to all
    public:
		/*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC ENUMS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief Configurations of the class
        union Config
        {
            //Checks to be performed on user dependent data
			static const bool CU1_EXTERNAL_CHECKS = true;
			//Checks to be performed on input dependent on internal algorithms
			static const bool CU1_INTERNAL_CHECKS = true;


			//true = pedantic count children. check all nodes, and make sure all nodes have coherent priority
			//false = fast count children. will return the max priority of the first children with the correct father, if any
			static const bool CU1_PEDANTIC_COUNT_CHILDREN = true;
        };

        //! @brief Error codes of the class
        union Error_code
        {
			//No error
			static constexpr const char *CPS8_OK = "OK";
			//Generic error
			static constexpr const char *CPS8_ERR = "ERR";
        };

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC TYPEDEFS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief Node of the tree
        struct Node
        {
			//Payload inside the node
			Payload t_payload;
			//Index of the father. using father means that there is no variable number of children index to maintain. all nodes have exactly one father except the root. It also makes it impossible to make loops. Root is the only node that has itself as father.
			unsigned int u32_index_father;
			//Priority, defines the order of this node compared to its siblings, 0 is the highest priority node under the given father.
			unsigned int u32_own_priority;
			//Max Priority, it's the number of siblings. A lone child has priority of 0 and a max_priority of 1. max_priority of 0 is error.
			//Adding a children would require modifying the max priority of all children.
			//Instead the max priority of a node is equivalent to the number of children. I already have father reference to access it.
			//So it's single edit when adding/removing children. Would be multi edit on all children otherwise
			unsigned int u32_children_max_priority;
        };

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  CONSTRUCTORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Empty Constructor
        Tree( void );
        //Default payload Constructor
        Tree( Payload it_default_payload );
        //Default payload and root Constructor
        Tree( Payload it_default_payload, Payload it_root_payload );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  DESTRUCTORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Empty destructor
        ~Tree( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC OPERATORS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        Payload& operator []( unsigned int iu32_index );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC SETTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Create a child of the root
		//std::vector<Node>::iterator create_child( Payload it_payload );
		bool create_child( Payload it_payload );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC GETTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//Reference to Payload of the root node, overload available to discard success
        Payload &root( bool &oru1_fail );
        Payload &root( void )
        {
			bool u1_fail;
			return this->root( u1_fail );
        }
        //Show the nodes stored inside the vector and their links
		bool show( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC TESTERS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC STATIC METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PUBLIC VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

    //Visible to derived classes
    protected:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PROTECTED TYPES
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **  PROTECTED VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

    //Visible only inside the class
    private:
        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE TYPES
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE INIT
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //! @brief initialize class vars to the default
        bool init_class_vars( Payload it_payload );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE METHODS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

        //Convert an iterator to a node to an index, its position in the vector
		bool convert_node_iterator_to_index( typename std::vector<Node>::iterator ipst_father, unsigned int &iru32_index );
        //Count the children of a node
        bool count_children( typename std::vector<Node>::iterator st_father, unsigned int &oru32_num_children );
		//Report an error. return false: OK | true: Unknown error code
        bool report_error( const char *ips8_error_code );
        //Tries to recover from an error. Automatically called by get_error. return false = OK | true = fail
        bool error_recovery( void );

        /*********************************************************************************************************************************************************
        **********************************************************************************************************************************************************
        **	PRIVATE VARS
        **********************************************************************************************************************************************************
        *********************************************************************************************************************************************************/

		//The nodes are stored inside a standard vector
        std::vector<Node> gast_nodes;
        //Iterator of the root
        //typename std::vector<Node>::iterator gpst_root;
        //Stores the node that is target for tree operations
        //typename std::vector<Node>::iterator pst_working_node;
};	//End Class: Tree

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	CONSTRUCTORS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Constructor: Tree | void
/***************************************************************************/
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::Tree( void )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //Initialize class vars
    this->init_class_vars( this->gt_dummy );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //Constructor: Tree | void

/***************************************************************************/
//! @brief Constructor: Tree | Payload |
/***************************************************************************/
//! @param it_default_payload | default payload
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::Tree( Payload it_default_payload )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    this->set_default_payload( it_default_payload );
    //Initialize class vars
    this->init_class_vars( it_default_payload );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //Constructor: Tree | Payload |

/***************************************************************************/
//! @brief Constructor: Tree | Payload | Payload |
/***************************************************************************/
//! @param it_default_payload | default payload
//! @return no return
//! @details
//! \n Empty constructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::Tree( Payload it_default_payload, Payload it_root_payload )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    this->set_default_payload( it_default_payload );
    //Initialize class vars
    this->init_class_vars( it_root_payload );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();  //Trace Return
    return;
}   //Constructor: Tree | Payload | Payload |

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	DESTRUCTORS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//!	@brief Destructor: Tree | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Empty destructor
/***************************************************************************/

template <class Payload>
Tree<Payload>::~Tree( void )
{
    DENTER_ARG("This: %p", this);   //Trace Enter
    //--------------------------------------------------------------------------
    //	INIT
    //--------------------------------------------------------------------------



    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return;         //OK
}   //Destructor: Tree | void

/***************************************************************************/
//!	@brief operator [] | int
/***************************************************************************/
//!	@param iu32_index | Numeric index of the node
//! @return Payload & | Reference to content of the node
//!	@details
//! LHS and RHS access to the payload of a node. Returns the reference to the
//!	dummy payload if an invalid index is given, raising an error inside the tree
/***************************************************************************/

template <class Payload>
Payload& Tree<Payload>::operator []( unsigned int iu32_index )
{
	//Trace Enter
	DENTER_ARG("Object: %p, Index: %d", (void *)this, iu32_index );
	//--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

	//The user is trying to access a node outside the range
    if (iu32_index >= this->gast_nodes.size())
    {
		DRETURN_ARG("Index OOB: %d of %d", iu32_index, this->gast_nodes.size() );
		//Return a reference to the dummy payload
		return this->gt_dummy;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
	//Trace Return from main
	DRETURN();
	return this->gast_nodes[iu32_index].t_payload;
}	//end method: operator & | int |

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC SETTERS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Public Setter: create_leaf | Payload
/***************************************************************************/
//! @param it_payload | payload to be attached to this leaf
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Create a child of the root
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::create_child( Payload it_payload )
{
    DENTER(); //Trace Enter
    //--------------------------------------------------------------------------
    //	CHECK&INIT
    //--------------------------------------------------------------------------
	//if class is in error, leaf cannot be created
    if (this->gps8_error_code != Error_code::CPS8_OK)
    {
		DRETURN_ARG("ERR:%d Tree is in error: %s | Cannot create leaf", __LINE__, this->gps8_error_code );
		return true;
    }

    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------
	//Create the node to add metadata to the payload
	Node st_node;
	st_node.t_payload = it_payload;
	//This node starts with no children
	st_node.u32_children_max_priority = 0;
	//Index of the root
	st_node.u32_index_father = 0;
	//Number of children of the father
	unsigned int u32_num_children = this->gast_nodes[ st_node.u32_index_father ].u32_children_max_priority;
    //By the end, I will have added a children to the father
	u32_num_children++;
	//I update the number of children of the father, thus the max priority of the father
	this->gast_nodes[ st_node.u32_index_father ].u32_children_max_priority = u32_num_children;
    //The newly created node has the lowest priority
    st_node.u32_own_priority = u32_num_children -1;
	//Add the node to the tree
	this->gast_nodes.push_back( st_node );

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN_ARG("Leaves: %d", u32_num_children +1 ); //Trace Return
    return false;	//OK
}   //Public Setter: create_leaf | Payload

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC GETTER
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Public getter: root | bool & |
/***************************************************************************/
//! @param oru1_fail | false = OK | true = FAIL
//! @return Payload & | Reference to the payload of the root node |
//! @details
//! \n Return the reference to the payload of the root node
/***************************************************************************/

template <class Payload>
Payload &Tree<Payload>::root( bool &oru1_fail )
{
    DENTER(); //Trace Enter
    //--------------------------------------------------------------------------
    //	INIT
    //--------------------------------------------------------------------------

    if (this->gast_nodes.size() <= 0)
    {
		this->report_error(Error_code::CPS8_ERR);
		return this->gt_dummy;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return this->gast_nodes[0].t_payload;
}   //Public getter: root | bool & |

/***************************************************************************/
//! @brief Public getter: show | void |
/***************************************************************************/
//! @param bool | false = OK | true = FAIL |
//! @details
//! \n Show the nodes stored inside the vector and their links
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::show( void )
{
    DENTER_ARG("Nodes: %d", this->gast_nodes.size()); //Trace Enter
    //--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

    if (this->gast_nodes.size() <= 0)
    {
		DRETURN_ARG("ERR:%d | Vector should contain at least the root...", __LINE__ );
		return true;
    }

    //--------------------------------------------------------------------------
    //	SHOW
    //--------------------------------------------------------------------------

	//Scan vector of nodes
    for (typename std::vector<Node>::iterator pst_node = this->gast_nodes.begin();pst_node < this->gast_nodes.end();pst_node++)
    {

		//std::ostream my_stream;
		unsigned int u32_node_index;
		this->convert_node_iterator_to_index( pst_node, u32_node_index );
		std::cout << "Index: " << u32_node_index << " | ";
		unsigned int u32_father_index = pst_node->u32_index_father;
		std::cout << "Father: " << u32_father_index;
		std::cout << " | Payload: " << pst_node->t_payload;
		//Root is the only node that has itself as father
		if (u32_node_index == u32_father_index)
		{
			std::cout << " | ROOT ";
		}
		//
		std::cout << "\n";
    }


    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return this->gast_nodes[0].t_payload;
}   //Public getter: show | void |


/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PUBLIC METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/


/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE INIT
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private Method: init_class_vars | void
/***************************************************************************/
// @param
//! @return no return
//! @details
//! \n Initialize class vars
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::init_class_vars( Payload it_payload )
{
    DENTER();		//Trace Enter
    //--------------------------------------------------------------------------
    //	INIT
    //--------------------------------------------------------------------------

	Node st_node;
    st_node.t_payload = it_payload;
    //Root starts with no children
	st_node.u32_children_max_priority = 0;
	//Root cannot have a priority
	st_node.u32_own_priority = 0;
    //Allocate root and fill root with dummy payload
    this->gast_nodes.push_back( st_node );
    if (this->gast_nodes.size() != 1)
    {
		//! @todo: Undo initialization
		this->report_error( Error_code::CPS8_ERR );
        DRETURN_ARG("ERR%d: There should be exactly one node (Root) after initialization, there are %d instead", __LINE__, this->gast_nodes.size() );
        return true;
    }
	//Register the father index. Root points to itself
    this->gast_nodes[0].u32_index_father = 0;

    this->gps8_error_code = Error_code::CPS8_OK;

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN();      //Trace Return
    return false;   //OK
}   //Private Method: init_class_vars | void

/*********************************************************************************************************************************************************
**********************************************************************************************************************************************************
**	PRIVATE METHODS
**********************************************************************************************************************************************************
*********************************************************************************************************************************************************/

/***************************************************************************/
//! @brief Private Method | convert_node_iterator_to_index | std::vector<Node>::iterator
/***************************************************************************/
//! @param std::vector<Node>::iterator | iterator to the node
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Convert an iterator to a node to an index, its position in the vector
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::convert_node_iterator_to_index( typename std::vector<Node>::iterator ipst_father, unsigned int &iru32_index )
{
    DENTER_ARG("This: %p, Father: %p", this, ipst_father );
    //--------------------------------------------------------------------------
    //	CHECK
    //--------------------------------------------------------------------------

    DPRINT("Begin: %p | End: %p\n", this->gast_nodes.begin(), this->gast_nodes.end() );
    if ( (Config::CU1_INTERNAL_CHECKS == true) && ((ipst_father < this->gast_nodes.begin()) || (ipst_father >= this->gast_nodes.end())) )
    {
		iru32_index = 0;
		DRETURN_ARG("ERR:%d | Iterator points to an address outside vector range | Index %d | Size: %d", __LINE__, ipst_father -this->gast_nodes.begin(), this->gast_nodes.end() -this->gast_nodes.begin() );
		return true;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------

	unsigned int u32_index = ipst_father -this->gast_nodes.begin();
	iru32_index = u32_index;
    DRETURN_ARG("Index: %d", u32_index );
    return false;
} 	//Private Method | convert_node_iterator_to_index | std::vector<Node>::iterator

/***************************************************************************/
//! @brief Private Method | report_error | Error_code
/***************************************************************************/
//! @param ips8_error_code | error string to be reported. Error strings can be stored in Error_code
//! @return bool | false = OK | true = FAIL |
//! @details
//! \n Report an error. return false: OK | true: Unknown error code
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::report_error( const char *ips8_error_code )
{
    DENTER_ARG("ERR: %p", ips8_error_code ); //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------

    //If class is OK
    if (ips8_error_code != Error_code::CPS8_OK)
    {
		//Report current error
		this->gps8_error_code = ips8_error_code;
    }
    else
    {
		//Class was already in error. Could not
		DRETURN_ARG("ERR: Class is already in error: %p | culd not report error: %p", &this->gps8_error_code, ips8_error_code );
		return true;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN(); //Trace Return
    return false;	//OK
} 	//Private Method: report_error | Error_code

/***************************************************************************/
//! @brief Private Method: error_recovery | void |
/***************************************************************************/
//! @return return false = OK | true = fail
//! @details
//! \n Tries to recover from an error
//! \n Automatically called by get_error.
/***************************************************************************/

template <class Payload>
bool Tree<Payload>::error_recovery( void )
{
    DENTER_ARG("ERR: %s", this->gps8_error_code); //Trace Enter
    //--------------------------------------------------------------------------
    //	BODY
    //--------------------------------------------------------------------------
	//If class is not OK
    if (this->gps8_error_code != Error_code::CPS8_OK)
    {
		//Class is OK
		this->gps8_error_code = Error_code::CPS8_OK;
    }

    //--------------------------------------------------------------------------
    //	RETURN
    //--------------------------------------------------------------------------
    DRETURN_ARG("Recovered: %s", this->gps8_error_code);      //Trace Return
    return false;    //FAIL
}   //Private Method: error_recovery | void |

/**********************************************************************************
**  NAMESPACE
**********************************************************************************/

}	//end namespace: User

#else
    #warning "Multiple inclusion of hader file TREE_H_"
#endif
